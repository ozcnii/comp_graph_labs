<!--
x = (R + r * cos(a)) * sin(b)
y = (R + r * cos(a)) * cos(b)
z = r * sin(a)

R – расстояние от центра образующей окружности до оси вращения
r – радиус образующей окружности

a ∈ [0, 2pi]
b ∈ [-pi,pi]
-->
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6203, Фокин Евгений Андреевич - Лабораторная работа №5</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
      }
      canvas {
        background-color: white;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
        justify-content: center;
      }
      .control-group {
        background-color: white;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
      }
      h1 {
        margin-bottom: 20px;
      }
      button {
        padding: 5px 10px;
        margin: 0 5px;
        cursor: pointer;
      }
      input[type="range"] {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <h1>Лабораторная работа №5<br />Группа 6203, Фокин Евгений Андреевич</h1>
    <div class="controls">
      <div class="control-group">
        <h3>Вращение</h3>
        <div>
          X: <input type="range" id="rotateX" min="0" max="360" value="0" />
        </div>
        <div>
          Y: <input type="range" id="rotateY" min="0" max="360" value="0" />
        </div>
        <div>
          Z: <input type="range" id="rotateZ" min="0" max="360" value="0" />
        </div>
        <button id="resetRotation">Сбросить вращение</button>
      </div>

      <div class="control-group">
        <h3>Положение</h3>
        <div>
          X:
          <input type="range" id="positionX" min="-200" max="200" value="0" />
        </div>
        <div>
          Y:
          <input type="range" id="positionY" min="-200" max="200" value="0" />
        </div>
        <div>
          Z:
          <input type="range" id="positionZ" min="-500" max="100" value="0" />
        </div>
        <button id="resetPosition">Сбросить положение</button>
      </div>

      <div class="control-group">
        <h3>Масштаб и параметры</h3>
        <div>
          Масштаб:
          <input type="range" id="scale" min="10" max="200" value="100" />
        </div>
        <div>
          R (основной радиус):
          <input type="range" id="paramR" min="50" max="200" value="100" />
        </div>
        <div>
          r (радиус трубы):
          <input type="range" id="paramr" min="10" max="100" value="40" />
        </div>
        <button id="resetScale">Сбросить масштаб</button>
      </div>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
      // Инициализация canvas
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      // Параметры тора
      let R = 100; // Основной радиус
      let r = 40; // Радиус трубы
      let scale = 1;
      let rotationX = 0;
      let rotationY = 0;
      let rotationZ = 0;
      let positionX = 0;
      let positionY = 0;
      let positionZ = 0;

      // Параметры проекции
      const fov = 500; // Угол обзора
      const cameraZ = 1000; // Положение камеры

      // Элементы управления
      const rotateXSlider = document.getElementById("rotateX");
      const rotateYSlider = document.getElementById("rotateY");
      const rotateZSlider = document.getElementById("rotateZ");
      const positionXSlider = document.getElementById("positionX");
      const positionYSlider = document.getElementById("positionY");
      const positionZSlider = document.getElementById("positionZ");
      const scaleSlider = document.getElementById("scale");
      const paramRSlider = document.getElementById("paramR");
      const paramrSlider = document.getElementById("paramr");

      document.getElementById("resetRotation").addEventListener("click", () => {
        rotationX = rotationY = rotationZ = 0;
        rotateXSlider.value = rotateYSlider.value = rotateZSlider.value = 0;
        drawTorus();
      });

      document.getElementById("resetPosition").addEventListener("click", () => {
        positionX = positionY = positionZ = 0;
        positionXSlider.value =
          positionYSlider.value =
          positionZSlider.value =
            0;
        drawTorus();
      });

      document.getElementById("resetScale").addEventListener("click", () => {
        scale = 1;
        R = 100;
        r = 40;
        scaleSlider.value = 100;
        paramRSlider.value = 100;
        paramrSlider.value = 40;
        drawTorus();
      });

      rotateXSlider.addEventListener("input", (e) => {
        rotationX = parseInt(e.target.value);
        drawTorus();
      });

      rotateYSlider.addEventListener("input", (e) => {
        rotationY = parseInt(e.target.value);
        drawTorus();
      });

      rotateZSlider.addEventListener("input", (e) => {
        rotationZ = parseInt(e.target.value);
        drawTorus();
      });

      positionXSlider.addEventListener("input", (e) => {
        positionX = parseInt(e.target.value);
        drawTorus();
      });

      positionYSlider.addEventListener("input", (e) => {
        positionY = parseInt(e.target.value);
        drawTorus();
      });

      positionZSlider.addEventListener("input", (e) => {
        positionZ = parseInt(e.target.value);
        drawTorus();
      });

      scaleSlider.addEventListener("input", (e) => {
        scale = parseInt(e.target.value) / 100;
        drawTorus();
      });

      paramRSlider.addEventListener("input", (e) => {
        R = parseInt(e.target.value);
        drawTorus();
      });

      paramrSlider.addEventListener("input", (e) => {
        r = parseInt(e.target.value);
        drawTorus();
      });

      function multiplyMatrix(a, b) {
        const result = [];
        for (let i = 0; i < 4; i++) {
          result[i] = [];
          for (let j = 0; j < 4; j++) {
            let sum = 0;
            for (let k = 0; k < 4; k++) {
              sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
          }
        }
        return result;
      }

      function multiplyMatrixVector(m, v) {
        const result = [0, 0, 0, 0];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            result[i] += m[i][j] * v[j];
          }
        }
        return result;
      }

      // Матрицы преобразований
      function getRotationXMatrix(angle) {
        const rad = (angle * Math.PI) / 180;
        return [
          [1, 0, 0, 0],
          [0, Math.cos(rad), -Math.sin(rad), 0],
          [0, Math.sin(rad), Math.cos(rad), 0],
          [0, 0, 0, 1],
        ];
      }

      function getRotationYMatrix(angle) {
        const rad = (angle * Math.PI) / 180;
        return [
          [Math.cos(rad), 0, Math.sin(rad), 0],
          [0, 1, 0, 0],
          [-Math.sin(rad), 0, Math.cos(rad), 0],
          [0, 0, 0, 1],
        ];
      }

      function getRotationZMatrix(angle) {
        const rad = (angle * Math.PI) / 180;
        return [
          [Math.cos(rad), -Math.sin(rad), 0, 0],
          [Math.sin(rad), Math.cos(rad), 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1],
        ];
      }

      function getTranslationMatrix(x, y, z) {
        return [
          [1, 0, 0, x],
          [0, 1, 0, y],
          [0, 0, 1, z],
          [0, 0, 0, 1],
        ];
      }

      function getScaleMatrix(s) {
        return [
          [s, 0, 0, 0],
          [0, s, 0, 0],
          [0, 0, s, 0],
          [0, 0, 0, 1],
        ];
      }

      // Функция для создания точек тора
      function createTorusPoints() {
        const points = [];
        const alphaSteps = 20; // Количество шагов по alpha
        const betaSteps = 30; // Количество шагов по beta

        for (let i = 0; i <= alphaSteps; i++) {
          const alpha = (i / alphaSteps) * Math.PI * 2;
          const circlePoints = [];

          for (let j = 0; j <= betaSteps; j++) {
            const beta = (j / betaSteps) * Math.PI * 2;

            // Параметрические уравнения тора
            const x = (R + r * Math.cos(alpha)) * Math.cos(beta);
            const y = (R + r * Math.cos(alpha)) * Math.sin(beta);
            const z = r * Math.sin(alpha);

            circlePoints.push([x, y, z, 1]);
          }

          points.push(circlePoints);
        }

        return points;
      }

      // Функция перспективной проекции
      function projectPoint(x, y, z) {
        // Применяем перспективу
        const factor = fov / (fov + z + cameraZ);
        const projectedX = x * factor + canvas.width / 2;
        const projectedY = y * factor + canvas.height / 2;

        // Возвращаем координаты и коэффициент глубины (для эффектов)
        return {
          x: projectedX,
          y: projectedY,
          depth: z,
        };
      }

      // Функция для отрисовки тора
      function drawTorus() {
        // Очищаем canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Создаем точки тора
        const torusPoints = createTorusPoints();

        // Создаем матрицу преобразований
        let transformationMatrix = [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 1],
        ];

        // Применяем преобразования в порядке: масштаб -> вращение -> перемещение
        transformationMatrix = multiplyMatrix(
          transformationMatrix,
          getScaleMatrix(scale)
        );
        transformationMatrix = multiplyMatrix(
          transformationMatrix,
          getRotationXMatrix(rotationX)
        );
        transformationMatrix = multiplyMatrix(
          transformationMatrix,
          getRotationYMatrix(rotationY)
        );
        transformationMatrix = multiplyMatrix(
          transformationMatrix,
          getRotationZMatrix(rotationZ)
        );
        transformationMatrix = multiplyMatrix(
          transformationMatrix,
          getTranslationMatrix(positionX, positionY, positionZ)
        );

        // Преобразуем и проектируем точки
        const projectedPoints = [];

        for (let i = 0; i < torusPoints.length; i++) {
          const circleProjected = [];
          for (let j = 0; j < torusPoints[i].length; j++) {
            // Применяем преобразования
            const transformed = multiplyMatrixVector(
              transformationMatrix,
              torusPoints[i][j]
            );

            // Применяем перспективную проекцию
            const projected = projectPoint(
              transformed[0],
              transformed[1],
              transformed[2]
            );

            circleProjected.push(projected);
          }
          projectedPoints.push(circleProjected);
        }

        // Рисуем тор
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 1;

        // Рисуем кольца вдоль alpha
        for (let i = 0; i < projectedPoints.length; i++) {
          ctx.beginPath();
          for (let j = 0; j < projectedPoints[i].length; j++) {
            const { x, y } = projectedPoints[i][j];
            if (j === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }

        // Рисуем кольца вдоль beta
        for (let j = 0; j < projectedPoints[0].length; j++) {
          ctx.beginPath();
          for (let i = 0; i < projectedPoints.length; i++) {
            const { x, y } = projectedPoints[i][j];
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }
      }

      // Начальная отрисовка
      drawTorus();
    </script>
  </body>
</html>
